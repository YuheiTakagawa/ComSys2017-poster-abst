\documentclass{ipsjpapers}
\usepackage[dvipdfmx]{graphicx}
\usepackage{comsys-poster}
\usepackage{multirow}
\usepackage{url}
\title{異種OSコンテナ・マイグレーション実現に向けた\\Linux-FreeBSD間プロセス・マイグレーション実現方式の検討}

\author{高川 雄平　松原 克弥}

\begin{document}
\maketitle

\section{はじめに}
近年，クラウドコンピューティングの基盤技術の一つであるコンテナ型仮想化が注目されてい
る\cite{focus-container}．コンテナ型仮想化は，OSが提供する資源を分離・制限し，単一動作
のOS上に複数の独立した実行環境を構築できる軽量な仮想化を実現する．

また，クラウドコンピューティング実動環境では，負荷分散や可用性の実現を目的にライブマイグ
レーションが活用される．ライブマイグレーションとは，サービスを実行している仮想マシンを動的に別のマシンに移動させる技術である．コンテナ型仮想化のライブマイグレーション(以下，コンテナ・マイグレーション)は，CRIU (Checkpoint/Restore in Userspace)\cite{criu}やFreeBSD VPS (Virtual Private System)\cite{freebsd-vps}
が実現している．しかし，コンテナ型仮想化の実装はOS依存のため，異種OS間におけるコンテ
ナ・マイグレーションは実現されていない．

コンテナ・マイグレーションを行うには，プロセス実行状態のマイグレーション(以下，プロセス・マイグレーション)とプロセス隔離状態のマイグレーションが必要になる．

本稿では，異種OSコンテナ・マイグレーション実現に向けた、異種OS間のプロセス・マイグレーションの実現方式の検討と実装を行う．なお，対象OSはlinuxとFreeBSDとする．


\section{各OSにおけるABIの差異}
\label{se:abi}
異種OSでは，ABI(Application Binary Interface)が異なる．ABIとは，アプリケーションとOSのインタフェースのことで，CPU命令セットやシステムコール，データ型，データ配置などを指す．LinuxとFreeBSDでは，主にシステムコールとメモリレイアウトに差異がある．

\begin{table}[t]
  \label{tb:syscall}
  \caption{openシステムコールにおけるOSの差異}
  \vspace{0.5em}
  \begin{center}
    \begin{tabular}{|c|c|c|} \hline
       & Linux & FreeBSD  \\ \hline \hline
      \shortstack{open()の\\システムコール番号} & \raisebox{0.5em}{2} & \raisebox{0.5em}{5} \\ \hline
      \shortstack{open()の\\引数オプション\\O\_CREAT} & \raisebox{1em}{0x0200} & \raisebox{1em}{0x0040} \\ \hline
      引数の渡し方 & レジスタ経由 & スタック経由  \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection{システムコール}
LinuxとFreeBSDでは，システムコールの実装は大半が同じである．しかし，システムコール番号や引数パラメータ，引数の渡し方が異なるため，LinuxバイナリとFreeBSDバイナリは各OS上でのみしか動作しない．表\ref{tb:syscall}には，openシステムコールにおける差異を示している．openシステムコール番号は，Linuxでは2，FreeBSDでは5となっている．openシステムコールでファイルを作成する際に引数として渡すO\_CREATは，Linuxでは0x0200，FreeBSDでは0x0040となっている．システムコールの引数を，Linuxではレジスタ，FreeBSDではスタックを経由してカーネルに渡している．以上のようなシステムコールの差異があるため，スタックの状態やレジスタの状態が異なる．
\subsection{メモリレイアウト}
メモリレイアウトは，仮想メモリ空間におけるデータ領域やスタック領域などの配置である．一般的にASLR(Address Space Layout Randomization)によって，各領域はランダムに配置される．また，ASLRを無効化して領域を固定した場合でも，LinuxとFreeBSDでは，ヒープ領域・スタック領域・共有ライブラリの配置に誤差がある．この誤差を純粋に修正する場合には，スタック内にある全てのベースアドレス，リターンアドレス，共有ライブラリ内の命令を示すアドレス，ヒープ領域の変数を参照するアドレスなどを見つけ出し，配置の誤差だけ移動する必要がある．

\section{プロセス・マイグレーションの実装}
プロセス・マイグレーションを行うには，プロセスを動作させるのに必要なレジスタやメモリの状態を保存(スナップショット)し，復元(レストア)する必要がある．スナップショット/レストアは，ptraceシステムコールを用いて行う．なお，監視する親プロセスをtracer，監視される子プロセスをtraceeと呼ぶ．
\subsection{スナップショット}
スナップショットでは，様々な情報を取得し，取得した情報をファイルに書き込む．以下には，レジスタとメモリの情報の取得方法を示す．\\
　レジスタ情報を取得するには，ptraceシステムコールのGETREGSを用いて，レジスタ情報を格納する構造体(以下，レジスタ構造体)から取得することができる．Linux\slash{}x64とFreeBSD\slash{}x64では，汎用レジスタ，インデックスレジスタ，セグメントレジスタなどが取得できる．\\
　メモリ情報を取得するには，procfsのmemファイルを読み込むことで取得できる．第\ref{se:conv}章で述べるLinuxバイナリ互換機能を用いることで，LinuxとFreeBSDで同じ実行バイナリファイルを実行できるため，テキスト領域や共有ライブラリを保存する必要はない．
\subsection{ABI変換}
\label{se:conv}
第\ref{se:abi}章で述べたように異種OSにはABIの差異がある．差異がある状態では，スナップショットで作成したファイルから正しくレストアすることはできない．異種OS間プロセス・マイグレーションはABIを変換することで実現できる．\\
　システムコールの差異に関しては，FreeBSDカーネル機能のLinuxバイナリ互換機能\cite{linux-emu}を用いることで解決する．Linuxバイナリ互換機能を用いると，システムコール番号，引数パラメータの変換，引数の渡し方の互換が可能になるため，スタックの状態やレジスタの状態を限りなく同じにすることができる．また，Linuxバイナリであれば，LinuxとFreeBSDでバイナリファイルを一切変更せずに動作させることができる．\\
　メモリレイアウトの差異に関しては，メモリレイアウト変更機能を用いる．毎回全ての領域に対して，メモリ内部の探索と移動を行うのはオーバーヘッドが大きい．そこで，スナップショット時とレストア時のメモリレイアウトを同じレイアウトにすることで，メモリ内部を変更することなく，メモリレイアウトの差異に対応できる．同じレイアウトにすることができるため，ASLRのランダムなメモリレイアウトも再現可能である．Linuxでは，prctlシステムコールで変更することができるが，FreeBSDでは変更機能がないため実装する必要がある．
\subsection{レストア}
レストアでは，スナップショットで作成したファイルを用いてレジスタとメモリの復元を行う．フォークをした子プロセスでLinuxバイナリを実行する．ただし，プロセス・マイグレーションを行うためには，main関数以降の本格的な実行が始まる前にレジスタとメモリの状態を復元する必要がある．そのため，main関数の命令でプロセスを止めるためにint3を書き込む．なお，エントリーポイントでレジスタやメモリの復元を行うこともできるが，Linuxバイナリ互換機能はmain関数前のスタートアップで適応されるため，本手法ではmain関数の命令で止める必要がある．

レジスタの復元は，レジスタ構造体を復元する情報に変更して，ptraceシステムコールのSETREGSでレジスタに反映させる．レジスタ構造体の情報を変更する場合に，構造体の差異とセグメントレジスタの扱いを考慮しなければならない．Linuxでは，システムコール番号をメンバ変数orig\_raxに格納し，システムコールの返り値をメンバ変数raxに格納するが，FreeBSDでは，どちらもメンバ変数raxに格納する．ripメンバ変数が指す命令からシステムコール実行の前後を判断して，FreeBSDのraxに格納する値を決める必要がある．また，メンバ変数の順番も異なるため，各OSが持つ構造体のメンバ変数に合わせて格納しなければならない．セグメントレジスタに関しては，Linux\slash{}x64とFreeBSD\slash{}x64では，各OSがプロセスごとに割り当てるため，OSに割り当てられた値以外を利用すると，セグメントフォルトが起こる．そのため，セグメントレジスタは，スナップショット時の値を利用せず，OSに割り当てられた値をそのまま利用する．

メモリを復元は，procfsのmemファイルに，データ領域，ヒープ領域，スタック領域のそれぞれに対してシークを行い，スナップショット時のメモリ状態を書き込む．第\ref{se:conv}章の変換を行うことで，メモリ情報を変更せずに，プロセスを復元することができる．しかし，環境変数ごとメモリに書き込まれてしまうため，環境変数を参照するようなプログラムに対しては，正しく復元できない．

\section{おわりに}
本稿では，異種OS間コンテナ・マイグレーション実現に向けた，プロセス・マイグレーションの検討と実装を行った．対象OSをLinuxとFreeBSDとし，システムコールに関する差異はLinuxバイナリ互換機能を用い，メモリレイアウトに関する差異は同じメモリレイアウト機能を用いて吸収する．\\
　今後の課題として，実運用に向けてネットワークソケットやファイルポインタなどのカーネル等プロセス外で管理されているプロセス関連情報を対象プロセスのマイグレーションに含める技術の実現がある．
\begin{thebibliography}{99}

  \bibitem{focus-container}
  	451 Research, "451 Research: Application containers will be a \$2.7bn market by 2020", 2017.
  \bibitem{criu}
  	CRIU Project: CRIU Main page, \url{https://criu.org/}, 2010 (accessed November 1 2017).
  \bibitem{freebsd-vps}
  Klaus P. Ohrhallinger: Virtual Private System for FreeBSD, \url{http://www.7he.at/freebsd/vps/}, 2010 (accessed November 6, 2017). EuroBSDCon 2010.
  \bibitem{linux-emu}
  Jim Mock: Linux Binary Compatibility, https://www.freebsd.org\slash{}doc\slash{}handbook\slash{}\\linuxemu.html, 1999 (accessed November 2, 2017).
\end{thebibliography}
\end{document}
